"undefined"==typeof exports&&(exports={}),Object.defineProperty(exports,"__esModule",{value:!0});class Enumerable{constructor(t){this._defaultComparer=(t,e)=>t>e?1:t<e?-1:0,_ensureIterable(t),this._src=t;const e=t[Symbol.iterator];this._generator=e?e.bind(t):t,this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1,this._useQuickSort=!0}static from(t){return t instanceof Enumerable?t:new Enumerable(t)}static empty(){const t=new Enumerable([]);return t._count=()=>0,t._tryGetAt=t=>null,t._canSeek=!0,t}static range(t,e){const n=new Enumerable((function*(){for(let n=0;n<e;n++)yield t+n}));return n._count=()=>e,n._tryGetAt=n=>n>=0&&n<e?{value:t+n}:null,n._canSeek=!0,n}static repeat(t,e){const n=new Enumerable((function*(){for(let n=0;n<e;n++)yield t}));return n._count=()=>e,n._tryGetAt=n=>n>=0&&n<e?{value:t}:null,n._canSeek=!0,n}[Symbol.iterator](){return this._wasIterated=!0,this._generator()}canSeek(){return this._ensureInternalTryGetAt(),this._canSeek}get length(){if(!this.canSeek())throw new Error("Calling length on this enumerable will iterate it. Use count()");return this.count()}concat(t){_ensureIterable(t);const e=this,n=new Enumerable((function*(){for(const t of e)yield t;for(const e of Enumerable.from(t))yield e})),r=Enumerable.from(t);return n._count=()=>e.count()+r.count(),this._ensureInternalTryGetAt(),r._ensureInternalTryGetAt(),n._canSeek=e._canSeek&&r._canSeek,e._canSeek&&(n._tryGetAt=t=>e._tryGetAt(t)||r._tryGetAt(t-e.count())),n}count(){return this._ensureInternalCount(),this._count()}distinct(t){const e=this;return new Enumerable(void 0===t?function*(){const t=new Set;for(const n of e){const e=t.size;t.add(n),e<t.size&&(yield n)}}:function*(){const n=[];for(const r of e){let e=!0;for(let o=0;o<n.length;o++)if(t(r,n[o])){e=!1;break}e&&(yield r),n.push(r)}})}elementAt(t){this._ensureInternalTryGetAt();const e=this._tryGetAt(t);if(!e)throw new Error("Index out of range");return e.value}elementAtOrDefault(t){this._ensureInternalTryGetAt();const e=this._tryGetAt(t);if(e)return e.value}first(){return this.elementAt(0)}firstOrDefault(){return this.elementAtOrDefault(0)}last(){if(this._ensureInternalTryGetAt(),!this._canSeek){let t=null,e=!1;for(const n of this)t=n,e=!0;if(e)return t;throw new Error("The enumeration is empty")}const t=this.count();return this.elementAt(t-1)}lastOrDefault(){if(this._ensureInternalTryGetAt(),!this._canSeek){let t=void 0;for(const e of this)t=e;return t}const t=this.count();return this.elementAtOrDefault(t-1)}stats(t){t?_ensureFunction(t):t=this._defaultComparer;const e={count:0,min:void 0,max:void 0},n=this[Symbol.iterator]();let r=n.next(),o=n.next();for(;!r.done&&!o.done;)t(r.value,o.value)>0?((void 0===e.max||t(r.value,e.max)>0)&&(e.max=r.value),(void 0===e.min||t(o.value,e.min)<0)&&(e.min=o.value)):((void 0===e.max||t(o.value,e.max)>0)&&(e.max=o.value),(void 0===e.min||t(r.value,e.min)<0)&&(e.min=r.value)),e.count+=2,r=n.next(),o=n.next();return r.done||(void 0===e.max||t(r.value,e.max)>0?e.max=r.value:(void 0===e.min||t(r.value,e.min)<0)&&(e.min=r.value),e.count++),e}min(t){const e=this.stats(t);return 0===e.count?void 0:e.min}max(t){const e=this.stats(t);return 0===e.count?void 0:e.max}select(t){_ensureFunction(t);const e=this,n=new Enumerable((function*(){let n=0;for(const r of e)yield t(r,n),n++}));return this._ensureInternalCount(),n._count=this._count,this._ensureInternalTryGetAt(),n._canSeek=e._canSeek,n._tryGetAt=n=>{const r=e._tryGetAt(n);return r?{value:t(r.value)}:r},n}skip(t){const e=this,n=new Enumerable((function*(){let n=t;for(const t of e)n>0?n--:yield t}));return n._count=()=>Math.max(0,e.count()-t),this._ensureInternalTryGetAt(),n._canSeek=this._canSeek,n._tryGetAt=n=>e._tryGetAt(n+t),n}splice(t,e,...n){return this.take(t).concat(n).concat(this.skip(t+e))}sum(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum}sumAndCount(){const t={count:0,sum:0};for(const e of this)t.sum=0===t.count?_toNumber(e):t.sum+_toNumber(e),t.count++;return t}take(t){const e=this,n=new Enumerable((function*(){let n=t;for(const t of e)if(n>0&&(yield t,n--),n<=0)break}));return n._count=()=>Math.min(t,e.count()),this._ensureInternalTryGetAt(),n._canSeek=e._canSeek,e._canSeek&&(n._tryGetAt=n=>n>=t?null:e._tryGetAt(n)),n}toArray(){var t;if(this._ensureInternalTryGetAt(),this._canSeek){const e=new Array(this.count());for(let n=0;n<e.length;n++)e[n]=null===(t=this._tryGetAt(n))||void 0===t?void 0:t.value;return e}let e=0;const n=[];for(const t of this)e===n.length&&(n.length+=64),n[e]=t,e++;return n.length=e,n}toList(){return this._ensureInternalTryGetAt(),this._canSeek?this:Enumerable.from(this.toArray())}where(t){_ensureFunction(t);const e=this;return new Enumerable((function*(){let n=0;for(const r of e)t(r,n)&&(yield r),n++}))}aggregate(t,e){_ensureFunction(e);for(const n of this)t=e(t,n);return t}all(t){return _ensureFunction(t),!this.any(e=>!t(e))}any(t){_ensureFunction(t);let e=0;for(const n of this){if(t(n,e))return!0;e++}return!1}append(t){return this.concat([t])}average(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum/t.count}asEnumerable(){return this}cast(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.select(n=>{if(!e(n))throw new Error(n+" not of type "+t);return n})}contains(t,e=((t,e)=>t==e)){return _ensureFunction(e),this.any(n=>e(n,t))}defaultIfEmpty(){throw new Error("defaultIfEmpty not implemented for Javascript")}except(t,e){_ensureIterable(t);const n=this,r=void 0===e?function*(){const e=Enumerable.from(t).toSet();for(const t of n)e.has(t)||(yield t)}:function*(){const r=_toArray(t);for(const t of n){let n=!0;for(let o=0;o<r.length;o++)if(e(t,r[o])){n=!1;break}n&&(yield t)}};return new Enumerable(r)}intersect(t,e){_ensureIterable(t);const n=this,r=void 0===e?function*(){const e=new Set(Enumerable.from(t));for(const t of n)e.has(t)&&(yield t)}:function*(){const r=_toArray(t);for(const t of n){let n=!0;for(let o=0;o<r.length;o++)if(e(t,r[o])){n=!1;break}n||(yield t)}};return new Enumerable(r)}longCount(){return this.count()}ofType(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.where(e)}prepend(t){return new Enumerable([t]).concat(this)}reverse(){this._ensureInternalTryGetAt();const t=this,e=this._canSeek?function*(){for(let e=t.count()-1;e>=0;e--)yield t.elementAt(e)}:function*(){const e=t.toArray();for(let t=e.length-1;t>=0;t--)yield e[t]},n=new Enumerable(e);if(this._ensureInternalCount(),n._count=this._count,this._ensureInternalTryGetAt(),this._canSeek){const t=this;n._canSeek=!0,n._tryGetAt=e=>t._tryGetAt(t.count()-e-1)}return n}selectMany(t){t?_ensureFunction(t):t=t=>t;const e=this;return new Enumerable((function*(){let n=0;for(const r of e){const e=t(r,n);_ensureIterable(e);for(const t of e)yield t;n++}}))}sequenceEqual(t,e=((t,e)=>t==e)){_ensureIterable(t),_ensureFunction(e);const n=this[Symbol.iterator](),r=Enumerable.from(t)[Symbol.iterator]();let o=!1;do{const t=n.next(),s=r.next();if(!(t.done&&s.done||!t.done&&!s.done&&e(t.value,s.value)))return!1;o=!!t.done}while(!o);return!0}single(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)throw new Error("Sequence contains no elements");const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n}singleOrDefault(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)return;const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n}slice(t=0,e){let n=this;return void 0!==e&&e>=0&&(t||0)<0&&(n=n.toList(),t=n.count()+t),0!==t&&(n=t>0?n.skip(t):n.takeLast(-t)),void 0!==e&&(n=e>=0?n.take(e-t):n.skipLast(-e)),n}skipLast(t){const e=this,n=new Enumerable((function*(){const n=t,r=Array(n);let o=0,s=0;for(const t of e){const e=r[o-s];r[o-s]=t,o++,o-s>=n&&(s+=n),o>n&&(yield e)}r.length=0}));return n._count=()=>Math.max(0,e.count()-t),this._ensureInternalTryGetAt(),n._canSeek=this._canSeek,this._canSeek&&(n._tryGetAt=t=>t>=n.count()?null:e._tryGetAt(t)),n}skipWhile(t){_ensureFunction(t);const e=this;let n=!0;return new Enumerable((function*(){let r=0;for(const o of e)n&&!t(o,r)&&(n=!1),n||(yield o),r++}))}takeLast(t){this._ensureInternalTryGetAt();const e=this,n=this._canSeek?function*(){const n=t,r=e.count();for(let t=r-n;t<r;t++)yield e.elementAt(t)}:function*(){const n=t;let r=0;const o=Array(n);for(const t of e)o[r%n]=t,r++;for(let t=0;t<n&&t<r;t++)yield o[(r+t)%n]},r=new Enumerable(n);return r._count=()=>Math.min(t,e.count()),r._canSeek=e._canSeek,e._canSeek&&(r._tryGetAt=n=>n<0||n>=r.count()?null:e._tryGetAt(e.count()-t+n)),r}takeWhile(t){_ensureFunction(t);const e=this;return new Enumerable((function*(){let n=0;for(const r of e){if(!t(r,n))break;yield r,n++}}))}toDictionary(){throw new Error("use toMap or toObject instead of toDictionary")}toMap(t,e=(t=>t)){_ensureFunction(t),_ensureFunction(e);const n=new Map;let r=0;for(const o of this)n.set(t(o,r),e(o,r)),r++;return n}toObject(t,e=(t=>t)){_ensureFunction(t),_ensureFunction(e);const n={};let r=0;for(const o of this)n[t(o,r)]=e(o),r++;return n}toHashSet(){throw new Error("use toSet instead of toHashSet")}toSet(){const t=new Set;for(const e of this)t.add(e);return t}union(t,e){return _ensureIterable(t),this.concat(t).distinct(e)}shuffle(){const t=this;const e=Enumerable.from((function*(){const e=t.toArray(),n=e.length;let r=0;for(;r<n;){const t=r+Math.floor(Math.random()*(n-r)),o=e[t];e[t]=e[r],e[r]=o,r++,yield o}}));return e._count=()=>t.count(),e}randomSample(t,e=Number.MAX_SAFE_INTEGER){let n=0;const r=[];if(this._ensureInternalTryGetAt(),this._canSeek){const n=this.count();let o=0;for(o=0;o<t&&o<e&&o<n;o++)r.push(this.elementAt(o));let s=Math.exp(Math.log(Math.random())/t);for(;o<n&&o<e;)o+=Math.floor(Math.log(Math.random())/Math.log(1-s))+1,o<n&&o<e&&(r[Math.floor(Math.random()*t)]=this.elementAt(o),s*=Math.exp(Math.log(Math.random())/t))}else for(const o of this){if(n<t)r.push(o);else{const e=Math.floor(Math.random()*n);e<t&&(r[e]=o)}if(n++,n>=e)break}return Enumerable.from(r)}distinctByHash(t){const e=this;return new Enumerable((function*(){const n=new Set;for(const r of e){const e=n.size;n.add(t(r)),e<n.size&&(yield r)}}))}exceptByHash(t,e){_ensureIterable(t);const n=this;return new Enumerable((function*(){const r=Enumerable.from(t).select(e).toSet();for(const t of n)r.has(e(t))||(yield t)}))}intersectByHash(t,e){_ensureIterable(t);const n=this;return new Enumerable((function*(){const r=Enumerable.from(t).select(e).toSet();for(const t of n)r.has(e(t))&&(yield t)}))}binarySearch(t,e=this._defaultComparer){const n=this.toList();let r=0,o=n.count()-1;for(;r<=o;){const s=r+o>>1,i=e(n.elementAt(s),t);if(0==i)return s;i<0?r=s+1:o=s-1}return!1}lag(t,e){if(!t)throw new Error("offset has to be positive");if(t<0)throw new Error("offset has to be positive. Use .lead if you want to join with next items");e?_ensureFunction(e):e=(t,e)=>[t,e];const n=this;this._ensureInternalTryGetAt();const r=new Enumerable((function*(){const r=Array(t);let o=0;for(const s of n){const n=o-t,i=n<0?void 0:r[n%t];yield e(s,i),r[o%t]=s,o++}}));return r._count=()=>{const t=n.count();return r._wasIterated||(r._wasIterated=n._wasIterated),t},n._canSeek&&(r._canSeek=!0,r._tryGetAt=r=>{const o=n._tryGetAt(r),s=n._tryGetAt(r-t);return o?{value:e(o.value,s?s.value:void 0)}:null}),r}lead(t,e){if(!t)throw new Error("offset has to be positive");if(t<0)throw new Error("offset has to be positive. Use .lag if you want to join with previous items");e?_ensureFunction(e):e=(t,e)=>[t,e];const n=this;this._ensureInternalTryGetAt();const r=new Enumerable((function*(){const r=Array(t);let o=0;for(const s of n){const n=o-t;if(n>=0){const o=r[n%t];yield e(o,s)}r[o%t]=s,o++}for(let n=0;n<t;n++){const s=r[(o+n)%t];yield e(s,void 0)}}));return r._count=()=>{const t=n.count();return r._wasIterated||(r._wasIterated=n._wasIterated),t},n._canSeek&&(r._canSeek=!0,r._tryGetAt=r=>{const o=n._tryGetAt(r),s=n._tryGetAt(r+t);return o?{value:e(o.value,s?s.value:void 0)}:null}),r}padEnd(t,e){if(t<=0)throw new Error("minLength has to be positive.");let n;n="function"!=typeof e?t=>e:e;const r=this;this._ensureInternalTryGetAt();const o=new Enumerable((function*(){let e=0;for(const t of r)yield t,e++;for(;e<t;e++)yield n(e)}));return o._count=()=>{const e=Math.max(t,r.count());return o._wasIterated||(o._wasIterated=r._wasIterated),e},r._canSeek&&(o._canSeek=!0,o._tryGetAt=e=>{const o=r._tryGetAt(e);return o||(e<t?{value:n(e)}:null)}),o}padStart(t,e){if(t<=0)throw new Error("minLength has to be positive.");let n;n="function"!=typeof e?t=>e:e;const r=this;this._ensureInternalTryGetAt();const o=new Enumerable((function*(){const e=Array(t);let o=0;const s=r[Symbol.iterator]();let i=!1,u=!1;do{const r=s.next();if(u=!!r.done,u||(e[o]=r.value,o++),i&&!u)yield r.value;else if(u||o===t){for(let e=0;e<t-o;e++)yield n(e);for(let t=0;t<o;t++)yield e[t];i=!0}}while(!u)}));return o._count=()=>{const e=Math.max(t,r.count());return o._wasIterated||(o._wasIterated=r._wasIterated),e},r._canSeek&&(o._canSeek=!0,o._tryGetAt=e=>{const o=r.count(),s=t-o;return s<=0?r._tryGetAt(e):e<s?{value:n(e)}:r._tryGetAt(e-s)}),o}zip(t,e){_ensureIterable(t),e?_ensureFunction(e):e=(t,e)=>[t,e];const n=this;return new Enumerable((function*(){let r=0;const o=n[Symbol.iterator](),s=Enumerable.from(t)[Symbol.iterator]();let i=!1;do{const t=o.next(),n=s.next();i=!(!t.done&&!n.done),i||(yield e(t.value,n.value,r)),r++}while(!i)}))}groupBy(t){_ensureFunction(t);const e=this;return new Enumerable((function*(){const n=new Map;let r=0;for(const o of e){const e=t(o,r),s=n.get(e);s?s.push(o):n.set(e,[o]),r++}for(const[t,e]of n){const n=new GroupEnumerable(e,t);yield n}}))}groupJoin(t,e,n,r,o){const s=this,i=void 0===o?function*(){var o;const i=new Enumerable(t).groupBy(n).toMap(t=>t.key,t=>t);let u=0;for(const t of s){const n=_toArray(null!==(o=i.get(e(t,u)))&&void 0!==o?o:[]);yield r(t,n),u++}}:function*(){let i=0;for(const u of s){const s=[];let c=0;for(const r of Enumerable.from(t))o(e(u,i),n(r,c))&&s.push(r),c++;yield r(u,s),i++}};return new Enumerable(i)}join(t,e,n,r,o){const s=this,i=void 0===o?function*(){const o=new Enumerable(t).groupBy(n).toMap(t=>t.key,t=>t);let i=0;for(const t of s){const n=o.get(e(t,i));if(n)for(const e of n)yield r(t,e);i++}}:function*(){let i=0;for(const u of s){let s=0;for(const c of Enumerable.from(t))o(e(u,i),n(c,s))&&(yield r(u,c)),s++;i++}};return new Enumerable(i)}toLookup(){throw new Error("use groupBy instead of toLookup")}orderBy(t){return t?_ensureFunction(t):t=t=>t,new OrderedEnumerable(this,t,!0)}orderByDescending(t){return t?_ensureFunction(t):t=t=>t,new OrderedEnumerable(this,t,!1)}useQuickSort(){return this._useQuickSort=!0,this}useBrowserSort(){return this._useQuickSort=!1,this}static sort(t,e){return _quickSort(t,0,t.length-1,e,0,Number.MAX_SAFE_INTEGER),t}_ensureInternalCount(){const t=this;if(t._count)return;if(t._src instanceof Enumerable){const e=t._src;return e._ensureInternalCount(),void(t._count=()=>e._count())}const e=t._src;"function"==typeof e||"number"!=typeof e.length?"number"!=typeof e.size?t._count=()=>{let e=0;for(const n of t)e++;return e}:t._count=()=>e.size:t._count=()=>e.length}_ensureInternalTryGetAt(){const t=this;if(t._tryGetAt)return;if(t._canSeek=!0,t._src instanceof Enumerable){const e=t._src;return e._ensureInternalTryGetAt(),t._tryGetAt=t=>e._tryGetAt(t),void(t._canSeek=e._canSeek)}if("string"==typeof t._src){const e=t._src;return void(t._tryGetAt=t=>t<e.length?{value:e.charAt(t)}:null)}if(Array.isArray(t._src)){const e=t._src;return void(t._tryGetAt=t=>t>=0&&t<e.length?{value:e[t]}:null)}const e=t._src;"function"==typeof t._src||"number"!=typeof e.length?(t._canSeek=!1,t._tryGetAt=e=>{let n=0;for(const r of t){if(e===n)return{value:r};n++}return null}):t._tryGetAt=t=>t<e.length&&void 0!==e[t]?{value:e[t]}:null}}class GroupEnumerable extends Enumerable{constructor(t,e){super(t),this.key=e}}class OrderedEnumerable extends Enumerable{constructor(t,e,n=!0){super(t),this._keySelectors=[],this._restrictions=[],e&&this._keySelectors.push({keySelector:e,ascending:n});const r=this;this._generator=function*(){const{startIndex:t,endIndex:e,arr:n}=this.getSortedArray();if(n)for(let r=t;r<e;r++)yield n[r]},this._count=()=>{const t=Enumerable.from(r._src).count(),{startIndex:e,endIndex:n}=this.getStartAndEndIndexes(r._restrictions,t);return n-e},this._canSeek=!1,this._tryGetAt=()=>{throw new Error("Ordered enumerables cannot seek")}}getSortedArray(){const t=this;let e,n,r=null;const o=Enumerable.from(t._src);if(o.canSeek()?({startIndex:e,endIndex:n}=t.getStartAndEndIndexes(t._restrictions,o.count())):(r=Array.from(t._src),({startIndex:e,endIndex:n}=t.getStartAndEndIndexes(t._restrictions,r.length))),e<n){r||(r=Array.from(t._src));return(t._useQuickSort?(t,r)=>_quickSort(t,0,t.length-1,r,e,n):(t,e)=>t.sort(e))(r,t.generateSortFunc(t._keySelectors)),{startIndex:e,endIndex:n,arr:r}}return{startIndex:e,endIndex:n,arr:null}}generateSortFunc(t){const e=t.map(t=>{const e=t.keySelector,n=(t,n)=>{const r=e(t),o=e(n);return r>o?1:r<o?-1:0};return t.ascending?n:(t,e)=>-n(t,e)});return 1==e.length?e[0]:(t,n)=>{for(let r=0;r<e.length;r++){const o=e[r](t,n);if(o)return o}return 0}}getStartAndEndIndexes(t,e){let n=0,r=e;for(const e of t)switch(e.type){case RestrictionType.take:r=Math.min(r,n+e.nr);break;case RestrictionType.skip:n=Math.min(r,n+e.nr);break;case RestrictionType.takeLast:n=Math.max(n,r-e.nr);break;case RestrictionType.skipLast:r=Math.max(n,r-e.nr)}return{startIndex:n,endIndex:r}}thenBy(t){return this._keySelectors.push({keySelector:t,ascending:!0}),this}thenByDescending(t){return this._keySelectors.push({keySelector:t,ascending:!1}),this}take(t){return this._restrictions.push({type:RestrictionType.take,nr:t}),this}takeLast(t){return this._restrictions.push({type:RestrictionType.takeLast,nr:t}),this}skip(t){return this._restrictions.push({type:RestrictionType.skip,nr:t}),this}skipLast(t){return this._restrictions.push({type:RestrictionType.skipLast,nr:t}),this}toArray(){const{startIndex:t,endIndex:e,arr:n}=this.getSortedArray();return n?n.slice(t,e):[]}toMap(t,e=(t=>t)){_ensureFunction(t),_ensureFunction(e);const n=new Map,r=this.toArray();for(let o=0;o<r.length;o++)n.set(t(r[o],o),e(r[o],o));return n}toObject(t,e=(t=>t)){_ensureFunction(t),_ensureFunction(e);const n={},r=this.toArray();for(let o=0;o<r.length;o++)n[t(r[o],o)]=e(r[o],o);return n}toSet(){const t=new Set,e=this.toArray();for(let n=0;n<e.length;n++)t.add(e[n]);return t}}var RestrictionType;!function(t){t[t.skip=0]="skip",t[t.skipLast=1]="skipLast",t[t.take=2]="take",t[t.takeLast=3]="takeLast"}(RestrictionType||(RestrictionType={}));const _insertionSortThreshold=64;function _insertionsort(t,e,n,r){for(let o=e;o<=n;o++){const n=t[o];let s=o-1;for(;s>=e&&r(t[s],n)>0;)t[s+1]=t[s],s--;t[s+1]=n}}function _swapArrayItems(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function _partition(t,e,n,r){const o=t[n+e>>1];for(;e<=n;){for(;r(t[e],o)<0;)e++;for(;r(t[n],o)>0;)n--;if(e<n)_swapArrayItems(t,e,n),e++,n--;else if(e===n)return e+1}return e}function _quickSort(t,e,n,r=((t,e)=>t>e?1:t<e?-1:0),o=0,s=Number.MAX_SAFE_INTEGER){if(!t.length)return t;const i=[];i.push({left:e,right:n});let u=1;for(;u;){const c=({left:e,right:n}=i[u-1]);if(n-e<64){_insertionsort(t,e,n,r),u--;continue}const a=_partition(t,e,n,r);e<a-1&&a-1>=o?(c.right=a-1,a<n&&a<s&&(i[u]={left:a,right:n},u++)):a<n&&a<s?c.left=a:u--}return t}function _ensureIterable(t){if(t){if(t[Symbol.iterator])return;if("function"==typeof t&&"GeneratorFunction"===t.constructor.name)return}throw new Error("the argument must be iterable!")}function _ensureFunction(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function _toNumber(t){return"number"==typeof t?t:Number.NaN}function _toArray(t){return t?Array.isArray(t)?t:Array.from(t):[]}exports.default=Enumerable,Linqer={Enumerable:Enumerable};